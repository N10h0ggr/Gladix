// detours.rs
//
// User-mode detours for a minimal, high-signal set of ntdll APIs. Each hook forwards the original
// call, then emits a protobuf Event{kind: Hook(..)} via IOCTL to the driver. The envelope carries
// pid/tid and the NTSTATUS returned by the original API. Per-API fields are small and stable so
// the hot path remains predictable. Reentrancy is avoided with a raw-TLS CallGuard.
//

#![allow(unsafe_code)]
use prost::Message;
use std::{ffi::c_void, mem, ptr, sync::Mutex, sync::OnceLock};
use windows::Wdk::System::Memory::SECTION_INHERIT;
use windows::Win32::{
    Foundation::UNICODE_STRING,
    Foundation::{HANDLE, NTSTATUS},
    Storage::FileSystem::{
        GetFinalPathNameByHandleW,
        FILE_NAME_NORMALIZED, FILE_NAME_OPENED, GETFINALPATHNAMEBYHANDLE_FLAGS,
    },
    System::Threading::{GetCurrentProcessId, GetCurrentThreadId},
};

use crate::call_guard::CallGuard;
use crate::comms::send_to_driver;
use crate::manager::{HookEntry, HookManager};

use shared::events::hook::{HookEvent, HookPayload, HookPayloadKind, NtCreateThreadExEvent, NtMapViewOfSectionEvent, NtProtectVirtualMemoryEvent, NtSetValueKeyEvent};
// Top-level envelope and module events generated by prost.
use shared::events::{Event, EventKind};

// Global HookManager stored once installation is done
static HOOK_MANAGER: OnceLock<Mutex<HookManager>> = OnceLock::new();

// Original function pointers patched by the detours
pub static mut ORIG_NT_CREATE_THREAD_EX:    *const c_void = ptr::null();
pub static mut ORIG_NT_MAP_VIEW_OF_SECTION: *const c_void = ptr::null();
pub static mut ORIG_NT_PROTECT_VIRTUAL_MEMORY:*const c_void = ptr::null();
pub static mut ORIG_NT_SET_VALUE_KEY:       *const c_void = ptr::null();

// ntdll signatures (subset)
type NtCreateThreadExFn = extern "system" fn(
    ThreadHandle: *mut HANDLE,
    DesiredAccess: u32,
    ObjectAttributes: *mut c_void,  // POBJECT_ATTRIBUTES
    ProcessHandle: HANDLE,
    StartRoutine: *mut c_void,
    Argument: *mut c_void,
    CreateFlags: u32,
    ZeroBits: usize,
    StackSize: usize,
    MaximumStackSize: usize,
    AttributeList: *mut c_void      // PPS_ATTRIBUTE_LIST
) -> NTSTATUS;

type NtMapViewOfSectionFn = extern "system" fn(
    SectionHandle: HANDLE,
    ProcessHandle: HANDLE,
    BaseAddress: *mut *mut c_void,
    ZeroBits: usize,
    CommitSize: usize,
    SectionOffset: *mut i64,        // PLARGE_INTEGER
    ViewSize: *mut usize,
    InheritDisposition: SECTION_INHERIT,
    AllocationType: u32,
    Win32Protect: u32
) -> NTSTATUS;

type NtProtectVirtualMemoryFn = extern "system" fn(
    ProcessHandle: HANDLE,
    BaseAddress: *mut *mut c_void,
    RegionSize: *mut usize,
    NewProtect: u32,
    OldProtect: *mut u32
) -> NTSTATUS;

type NtSetValueKeyFn = extern "system" fn(
    KeyHandle: HANDLE,
    ValueName: *mut UNICODE_STRING,
    TitleIndex: u32,
    Type: u32,
    Data: *const u8,
    DataSize: u32
) -> NTSTATUS;

// ────────────────────────────────────────────────────
// Hooks
// ────────────────────────────────────────────────────

#[unsafe(no_mangle)]
pub unsafe extern "system" fn MyNtCreateThreadExHook(
    thread_handle: *mut HANDLE,
    desired_access: u32,
    object_attributes: *mut c_void,
    process_handle: HANDLE,
    start_routine: *mut c_void,
    argument: *mut c_void,
    create_flags: u32,
    zero_bits: usize,
    stack_size: usize,
    maximum_stack_size: usize,
    attribute_list: *mut c_void,
) -> NTSTATUS {
    let _guard = match CallGuard::enter() {
        Some(g) => g,
        None => {
            let real: NtCreateThreadExFn = mem::transmute(ORIG_NT_CREATE_THREAD_EX);
            return real(
                thread_handle, desired_access, object_attributes, process_handle, start_routine,
                argument, create_flags, zero_bits, stack_size, maximum_stack_size, attribute_list,
            );
        }
    };

    call_and_report(
        || {
            let real: NtCreateThreadExFn = mem::transmute(ORIG_NT_CREATE_THREAD_EX);
            real(
                thread_handle, desired_access, object_attributes, process_handle, start_routine,
                argument, create_flags, zero_bits, stack_size, maximum_stack_size, attribute_list,
            )
        },
        |_status| {
            HookPayloadKind::NtCreateThreadEx(NtCreateThreadExEvent {
                start_routine:  start_routine as u64,
                start_argument: argument as u64,
                create_flags:   create_flags,
                process_handle: process_handle.0 as u64,
                desired_access: desired_access,
            })
        },
    )
}

#[unsafe(no_mangle)]
pub unsafe extern "system" fn MyNtMapViewOfSectionHook(
    section_handle: HANDLE,
    process_handle: HANDLE,
    base_address: *mut *mut c_void,
    zero_bits: usize,
    commit_size: usize,
    section_offset: *mut i64,
    view_size: *mut usize,
    inherit_disposition: SECTION_INHERIT,
    allocation_type: u32,
    win32_protect: u32,
) -> NTSTATUS {
    let _guard = match CallGuard::enter() {
        Some(g) => g,
        None => {
            let real: NtMapViewOfSectionFn = mem::transmute(ORIG_NT_MAP_VIEW_OF_SECTION);
            return real(
                section_handle, process_handle, base_address, zero_bits, commit_size,
                section_offset, view_size, inherit_disposition, allocation_type, win32_protect,
            );
        }
    };

    call_and_report(
        || {
            let real: NtMapViewOfSectionFn = mem::transmute(ORIG_NT_MAP_VIEW_OF_SECTION);
            real(
                section_handle, process_handle, base_address, zero_bits, commit_size,
                section_offset, view_size, inherit_disposition, allocation_type, win32_protect,
            )
        },
        |_status| {
            let va = if !base_address.is_null() { *base_address } else { ptr::null_mut() };
            let vs = view_size.as_ref().copied().unwrap_or(0);
            HookPayloadKind::NtMapViewOfSection(NtMapViewOfSectionEvent {
                base_address:   va as usize as u64,
                view_size:      vs as u64,
                win32_protect:  win32_protect,
                allocation_type: allocation_type,
                process_handle: process_handle.0 as u64,
            })
        },
    )
}

#[unsafe(no_mangle)]
pub unsafe extern "system" fn MyNtProtectVirtualMemoryHook(
    process_handle: HANDLE,
    base_address: *mut *mut c_void,
    region_size: *mut usize,
    new_protect: u32,
    old_protect: *mut u32,
) -> NTSTATUS {
    let _guard = match CallGuard::enter() {
        Some(g) => g,
        None => {
            let real: NtProtectVirtualMemoryFn = mem::transmute(ORIG_NT_PROTECT_VIRTUAL_MEMORY);
            return real(process_handle, base_address, region_size, new_protect, old_protect);
        }
    };

    call_and_report(
        || {
            let real: NtProtectVirtualMemoryFn = mem::transmute(ORIG_NT_PROTECT_VIRTUAL_MEMORY);
            real(process_handle, base_address, region_size, new_protect, old_protect)
        },
        |_status| {
            let old = if !old_protect.is_null() { *old_protect } else { 0 };
            HookPayloadKind::NtProtectVirtualMemory(NtProtectVirtualMemoryEvent {
                base_address: (*base_address) as usize as u64,
                region_size:  region_size.as_ref().copied().unwrap_or(0) as u64,
                new_protect:  new_protect,
                old_protect:  old,
            })
        },
    )
}

#[unsafe(no_mangle)]
pub unsafe extern "system" fn MyNtSetValueKeyHook(
    key_handle: HANDLE,
    value_name: *mut UNICODE_STRING,
    title_index: u32,
    value_type: u32,
    data: *const u8,
    data_size: u32,
) -> NTSTATUS {
    let _guard = match CallGuard::enter() {
        Some(g) => g,
        None => {
            let real: NtSetValueKeyFn = mem::transmute(ORIG_NT_SET_VALUE_KEY);
            return real(key_handle, value_name, title_index, value_type, data, data_size);
        }
    };

    let name = uni_to_string(value_name);

    call_and_report(
        || {
            let real: NtSetValueKeyFn = mem::transmute(ORIG_NT_SET_VALUE_KEY);
            real(key_handle, value_name, title_index, value_type, data, data_size)
        },
        |_status| {
            HookPayloadKind::NtSetValueKey(NtSetValueKeyEvent {
                key_path:   get_path_from_handle(key_handle), // best effort; may be ""
                value_name: name,
                value_type,
                data_size,
            })
        },
    )
}

// ────────────────────────────────────────────────────
// Public helpers
// ────────────────────────────────────────────────────

/// Installs the selected high-signal detours in the current process.
///
/// Returns:
/// - `Ok(())` on success.
/// - `Err(String)` if hooks are already installed or a detour fails during setup.
///
/// Precautions:
/// - Must not run under the loader lock. Call once per process during normal initialization.
pub fn install_all_hooks() -> Result<(), String> {
    let mut mgr = HookManager::new();

    mgr.add(HookEntry {
        dll: "ntdll.dll", func: "NtCreateThreadEx",
        detour:   MyNtCreateThreadExHook as *const u8,
        orig_ptr: unsafe { &raw mut ORIG_NT_CREATE_THREAD_EX },
    });
    mgr.add(HookEntry {
        dll: "ntdll.dll", func: "NtMapViewOfSection",
        detour:   MyNtMapViewOfSectionHook as *const u8,
        orig_ptr: unsafe { &raw mut ORIG_NT_MAP_VIEW_OF_SECTION },
    });
    mgr.add(HookEntry {
        dll: "ntdll.dll", func: "NtProtectVirtualMemory",
        detour:   MyNtProtectVirtualMemoryHook as *const u8,
        orig_ptr: unsafe { &raw mut ORIG_NT_PROTECT_VIRTUAL_MEMORY },
    });
    mgr.add(HookEntry {
        dll: "ntdll.dll", func: "NtSetValueKey",
        detour:   MyNtSetValueKeyHook as *const u8,
        orig_ptr: unsafe { &raw mut ORIG_NT_SET_VALUE_KEY },
    });

    mgr.install_all();

    HOOK_MANAGER
        .set(Mutex::new(mgr))
        .map_err(|_| "hooks already installed".to_owned())?;

    Ok(())
}

/// Uninstalls all detours installed by `install_all_hooks`. Safe during shutdown as long as no
/// other threads are executing hooked code.
pub fn uninstall_all_hooks() -> Result<(), String> {
    if let Some(mgr_cell) = HOOK_MANAGER.get() {
        if let Ok(mut mgr) = mgr_cell.lock() {
            mgr.uninstall_all();
        }
    }
    Ok(())
}

// ────────────────────────────────────────────────────
// Private helpers
// ────────────────────────────────────────────────────

/// Encodes and sends the top-level Event. Oversized messages are dropped to avoid clogging IOCTL.
const MAX_EVENT_SIZE: usize = 2048;

unsafe fn call_and_report<F, P>(call_real: F, payload_fn: P) -> NTSTATUS
where
    F: FnOnce() -> NTSTATUS,
    P: FnOnce(NTSTATUS) -> HookPayloadKind,
{
    let status = call_real();

    let event = Event {
        kind: Some(EventKind::Hook(HookEvent {
            pid:    GetCurrentProcessId(),
            tid:    GetCurrentThreadId(),
            status: status.0,
            payload: Some(HookPayload { payload: Some(payload_fn(status)) }),
        })),
    };

    let _ = encode_and_send(&event);
    status
}

fn encode_and_send(event: &Event) -> Result<(), prost::EncodeError> {
    let len = event.encoded_len();
    if len > MAX_EVENT_SIZE {
        return Ok(());
    }
    let mut buf = [0u8; MAX_EVENT_SIZE];
    event.encode(&mut &mut buf[..len])?;
    send_to_driver(&buf[..len]);
    Ok(())
}

/// Best-effort resolution of a file/registry handle to a normalized path. Uses the windows crate
/// signature that takes a mutable UTF-16 slice and returns the char count. Returns "" on failure.
unsafe fn get_path_from_handle(handle: HANDLE) -> String {
    let mut buf: [u16; 260] = [0; 260];
    let flags = GETFINALPATHNAMEBYHANDLE_FLAGS(FILE_NAME_OPENED.0 | FILE_NAME_NORMALIZED.0);
    let len = GetFinalPathNameByHandleW(handle, &mut buf, flags);
    if len == 0 || (len as usize) > buf.len() {
        return String::new();
    }
    String::from_utf16_lossy(&buf[..len as usize])
}

/// Converts a UNICODE_STRING to a Rust String; returns "" on invalid pointers or empty names.
unsafe fn uni_to_string(us: *const UNICODE_STRING) -> String {
    if us.is_null() {
        return String::new();
    }
    let u = &*us;
    let buf_ptr = u.Buffer.0;
    if buf_ptr.is_null() {
        return String::new();
    }
    let len = (u.Length / 2) as usize;
    let slice = std::slice::from_raw_parts(buf_ptr as *const u16, len);
    String::from_utf16_lossy(slice)
}
