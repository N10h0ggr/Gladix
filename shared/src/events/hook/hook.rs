// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HookEvent {
    /// Process/thread that triggered the hook.
    #[prost(uint32, tag = "1")]
    pub pid: u32,
    #[prost(uint32, tag = "2")]
    pub tid: u32,
    /// NTSTATUS returned by the original API (signed 32-bit in prost).
    #[prost(int32, tag = "3")]
    pub status: i32,
    /// Per-API payload.
    #[prost(message, optional, tag = "4")]
    pub payload: ::core::option::Option<HookPayload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HookPayload {
    #[prost(oneof = "hook_payload::Payload", tags = "1, 2, 3, 4")]
    pub payload: ::core::option::Option<hook_payload::Payload>,
}
/// Nested message and enum types in `HookPayload`.
pub mod hook_payload {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        NtCreateThreadEx(super::NtCreateThreadExEvent),
        #[prost(message, tag = "2")]
        NtMapViewOfSection(super::NtMapViewOfSectionEvent),
        #[prost(message, tag = "3")]
        NtProtectVirtualMemory(super::NtProtectVirtualMemoryEvent),
        #[prost(message, tag = "4")]
        NtSetValueKey(super::NtSetValueKeyEvent),
    }
}
/// Remote or local thread creation. Detects classic CreateRemoteThreadEx and
/// process-hollowing thread startups; StartRoutine/Argument are useful triage fields.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NtCreateThreadExEvent {
    /// thread entry point
    #[prost(uint64, tag = "1")]
    pub start_routine: u64,
    /// user argument
    #[prost(uint64, tag = "2")]
    pub start_argument: u64,
    /// THREAD_CREATE_*
    #[prost(uint32, tag = "3")]
    pub create_flags: u32,
    /// raw HANDLE to detect remote vs local
    #[prost(uint64, tag = "4")]
    pub process_handle: u64,
    /// requested access mask
    #[prost(uint32, tag = "5")]
    pub desired_access: u32,
}
/// Section-based injections and manual maps. Remote mappings stand out via ProcessHandle.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NtMapViewOfSectionEvent {
    /// result base after call if available
    #[prost(uint64, tag = "1")]
    pub base_address: u64,
    /// view size after call if available
    #[prost(uint64, tag = "2")]
    pub view_size: u64,
    /// PAGE_*
    #[prost(uint32, tag = "3")]
    pub win32_protect: u32,
    /// MEM_*
    #[prost(uint32, tag = "4")]
    pub allocation_type: u32,
    /// raw HANDLE (remote if not current process)
    #[prost(uint64, tag = "5")]
    pub process_handle: u64,
}
/// RX/RWX flips highlight unpacking, shellcode staging and similar behaviors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NtProtectVirtualMemoryEvent {
    #[prost(uint64, tag = "1")]
    pub base_address: u64,
    #[prost(uint64, tag = "2")]
    pub region_size: u64,
    #[prost(uint32, tag = "3")]
    pub new_protect: u32,
    /// value returned by the API
    #[prost(uint32, tag = "4")]
    pub old_protect: u32,
}
/// Registry writes are strong persistence indicators.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NtSetValueKeyEvent {
    /// best-effort; may be empty if resolution fails
    #[prost(string, tag = "1")]
    pub key_path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value_name: ::prost::alloc::string::String,
    /// REG_*
    #[prost(uint32, tag = "3")]
    pub value_type: u32,
    #[prost(uint32, tag = "4")]
    pub data_size: u32,
}
